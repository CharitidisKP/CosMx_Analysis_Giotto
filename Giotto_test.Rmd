```{r Libraries}

library(reticulate)
python_path <- "/mnt/home/koncha/anaconda3/envs/giotto_Py_3_11/bin/python3"
use_python(python_path, required = TRUE)

library(Giotto)
library(Matrix)
library(terra)
library(tidyverse)
library(data.table)
library(pheatmap)
library(igraph)
library(patchwork)
library(viridis)
library(cowplot)
library(ggpubr)

source(file = "/mnt/home/koncha/P_lab/CosMx_analysis/Scripts/Helper_Functions.R")

```

```{r Paths and instructions}

main_dir <- file.path("~/P_lab/CosMx_analysis")
results_folder <- file.path("~/P_lab/CosMx_analysis/Test_data/Results")
output_directory <- file.path("~/P_lab/CosMx_analysis/Output")

instructions <- createGiottoInstructions(
    save_dir = results_folder,
    save_plot = TRUE,
    show_plot = TRUE,
    return_plot = FALSE, 
    python_path = python_path
)

data_path <- file.path("/mnt/home/koncha/P_lab/CosMx_analysis/Test_data/Lung5_Rep1/Lung5_Rep1-Flat_files_and_images")
fov_shifts <- file.path(data_path, "Lung5_Rep1_fov_positions_file.csv")

```

```{r Create the CosMx Giotto object}

cosmx <- createGiottoCosMxObject(
  cosmx_dir = data_path,
  version = "legacy",
  poly_pref = "mask",
  load_expression = TRUE,
  load_transcripts = FALSE,           
  load_cellmeta = TRUE,
  feat_type = c("rna", "SystemControl"),
  split_keyword = list("SystemControl"),
  fov_shifts_path = fov_shifts,      
  instructions = instructions
)

```

```{r Check what is included}

slotNames(cosmx)

try(Giotto::showGiottoSpatLocs(cosmx), silent = TRUE)
try(Giotto::showGiottoPolygons(cosmx), silent = TRUE)

names(cosmx@spatial_info)
str(cosmx@spatial_info, max.level = 3)

head(cosmx@cell_ID$cell, 10)
table(sub("^c_(\\d+)_(\\d+)_.*$", "\\2", cosmx@cell_ID$cell))[1:10]

```

```{r Prep the functions for the polygons and load the shifts}

get_fov <- function(f) as.integer(sub(".*_F(\\d+)\\.tif$", "\\1", basename(f)))

## Load masks ##
mask_dir <- file.path(data_path, "CellLabels")
mask_files <- sort(list.files(mask_dir, pattern = "\\.tif$", full.names = TRUE))
stopifnot(length(mask_files) > 0)

## Load shifts ##
shifts <- as.data.table(read.csv(fov_shifts))
setnames(shifts, tolower(names(shifts)))
stopifnot(all(c("fov", "x_global_px", "y_global_px") %in% names(shifts)))

## Infer the sample/run index from the cell IDs ##
sample_id <- sub("^c_(\\d+)_.*$", "\\1", cosmx@cell_ID$cell[1])

```


```{r Create the polygon file from the cell labels}

## Build polygons per FOV, fix IDs, shift to global coords, merge ##
## Function to make the polygons for each file ##
build_gp <- function(maskfile, fov, dx, dy, sample_id) {

  ## Build polygons from label mask ##
  gp <- createGiottoPolygonsFromMask(maskfile = maskfile)

  ##Polygon IDs are stored as the first attribute column in the SpatVector ##
  vals <- terra::values(gp@spatVector)
  stopifnot(ncol(vals) >= 1)

  poly_col <- names(vals)[1]
  pid <- as.character(vals[[poly_col]])

  cellnum <- sub("^cell_", "", pid)

  ## Map polygon IDs to Giotto cell IDs ##
  new_ids <- paste0("c_", sample_id, "_", fov, "_", cellnum)

  ## Write back IDs ##
  vals[[poly_col]] <- new_ids
  terra::values(gp@spatVector) <- vals
  gp@unique_ID_cache <- new_ids

  ## Shift the current fov to global coordinates ##
  gp@spatVector <- terra::shift(gp@spatVector, dx = dx, dy = dy)

  ## Return the polygon df ##
  gp
}

## Make and merge the polygon files into a list ##
poly_list <- tibble(maskfile = mask_files) %>%
  mutate(fov = map_int(maskfile, get_fov)) %>%
  left_join(as_tibble(shifts), by = "fov") %>%
  { 
    ## Stop if any shift is missing or duplicated ##
    stopifnot(!any(is.na(.$x_global_px) | is.na(.$y_global_px)))
    stopifnot(!anyDuplicated(.$fov))
    ## After checks pass the data through instead of TRUE/FALSE ##
    .
  } %>%
  mutate(gp = pmap(
    ## Parallel mapping of the build_gp function to the given vectors ##
      list(maskfile, fov, x_global_px, y_global_px),
      ~ build_gp(..1, ..2, ..3, ..4, sample_id = sample_id)
      )
    ) %>%
  pull(gp)
  
## Merge all polygon SpatVectors into one
sv_all <- do.call(rbind, lapply(poly_list, \(gp) gp@spatVector))

## Create a polygon object using the first one from the list to get the slot names / metadata ##
gp_all <- poly_list[[1]]

## Include all the files ##
gp_all@spatVector <- sv_all

##  Get all the IDs ##
vals_all <- terra::values(gp_all@spatVector)

## Get the slot name ##
poly_col_all <- names(vals_all)[1]

## Replace the unique_ID_cache slot with all the cell IDs ## 
gp_all@unique_ID_cache <- as.character(vals_all[[poly_col_all]])

## Add polygons to object ##
## Use a named list so it lands under spatial_info$cell ##
cosmx <- addGiottoPolygons(
  gobject = cosmx,
  gpolygons = list(cell = gp_all)
)

## Optionally register polygons as centroids into spatial locations. Useful for a spatlocs layer derived from polygon centroids ##
cosmx <- setPolygonInfo(
  gobject = cosmx,
  x = list(cell = gp_all),
  centroids_to_spatlocs = TRUE
)

```

```{r Giotto summary report}

giotto_report_summary <- function(gobj) {

  n_cells <- tryCatch(length(gobj@cell_ID$cell), error = function(e) NA_integer_)
  n_feats <- tryCatch(length(gobj@feat_ID$rna), error = function(e) NA_integer_)

  spat_names <- tryCatch(names(gobj@spatial_info), error = function(e) character(0))
  has_polys <- "cell" %in% spat_names && !is.null(gobj@spatial_info$cell)
  n_polys <- if (has_polys) tryCatch(terra::nrow(gobj@spatial_info$cell@spatVector),
                                        error = function(e) NA_integer_) else 0

  poly_ids <- if (has_polys) tryCatch(gobj@spatial_info$cell@unique_ID_cache,
                                      error = function(e) character(0)) else character(0)
  cell_ids <- tryCatch(gobj@cell_ID$cell, error = function(e) character(0))

  overlap <- length(intersect(poly_ids, cell_ids))
  poly_only <- length(setdiff(poly_ids, cell_ids))
  cell_only <- length(setdiff(cell_ids, poly_ids))

  fov_tab <- tryCatch({
    FOV <- sub("^c_(\\d+)_(\\d+)_.*$", "\\2", cell_ids)
    tibble(FOV = FOV) %>%
      count(FOV, name = "Cells") %>%
      mutate(FOV = as.integer(FOV)) %>%
      arrange(FOV)
  }, error = function(e) tibble(FOV = integer(), Cells = integer()))

  list(
    overview = tibble(
      Metric = c(
        "Cells",
        "Genes (RNA features)",
        "Spatial info entries",
        "Cell polygons present",
        "Cell polygons"
      ),
      Value = c(
        n_cells,
        n_feats,
        paste(spat_names, collapse = ", "),
        has_polys,
        n_polys
      )
    ),
    polygon_id_check = tibble(
      Metric = c(
        "Polygon IDs",
        "Cell IDs",
        paste0("Overlap (polygon \u2229 cell)"),
        "Polygon-only IDs",
        "Cell-only IDs"
      ),
      Value = c(
        length(poly_ids),
        length(cell_ids),
        overlap,
        poly_only,
        cell_only
      )
    ),
    fov_cells = fov_tab
  )
}

```

```{r Giotto object summaries}

sum <- giotto_report_summary(cosmx)

nbsp <- "\u00A0"

knitr::kable(sum$overview,
  caption = paste0("Giotto", nbsp, "object", nbsp, "overview")
)

knitr::kable(sum$polygon_id_check,
  caption = paste0("Polygon", nbsp, "ID", nbsp, "\u2194", nbsp, "Cell", nbsp, "ID", nbsp, "consistency")
)

knitr::kable(sum$fov_cells,
  caption = paste0("Cells", nbsp, "per", nbsp, "FOV")
)

```


```{r Filtering function and thresholds}

## Filtering parameters ##
filter_cosmx_giotto <- function(
  gobj,
  feat_type = "rna",
  spat_unit = "cell",
  values = "raw", 
  expr_threshold = 1,
  ## Keep_genes: > 0 in at least 1 cell ##
  gene_min_cells = 1,
  ## Gene counts per cell > 50 ##
  cell_min_genes = 50,             
  ## Gene counts per cell < 2000 ##
  cell_max_genes = 2000,  
  ## Threshold_area = 5 * geom_mean_area (per Sample) ##
  area_gm_mult = 5,
  ## Per-group quantile thresholds ##
  bg_quantile = 0.99,
  ## Fallback if non-finite ##
  bg_fallback = 0.05,              
  filter_tissue_outliers = TRUE,
  ## x/y quantiles per Sample ##
  tissue_q = c(0.005, 0.995), 
  tissue_group = c("Sample", "fov"))
{

  ## Standard Giotto matrix-based filtering ##
  gobj <- filterGiotto(
    gobj,
    feat_type = feat_type,
    expression_threshold = expr_threshold,
    feat_det_in_min_cells = gene_min_cells,
    min_det_feats_per_cell = cell_min_genes
  )

  ## Compute QC metrics from expression and metadata ##
  counts <- getExpression(gobj, feat_type = feat_type, spat_unit = spat_unit, values = values)@exprMat

  ## Extract metadata ##
  meta <- pDataDT(gobj) %>% 
    as_tibble()  
  
  ## Ensure a cell_ID column exists ##
  if (!"cell_ID" %in% names(meta)) {
    meta <- meta %>% 
      mutate(cell_ID = colnames(counts))
  }

  ## QC metrics ##
  qc <- meta %>%
    mutate(
      Total_Counts = Matrix::colSums(counts),
      Num_Features = Matrix::colSums(counts > 0)
    )
  
  ## Negative probs ##
  neg_genes <- rownames(counts)[grepl("^NegPrb", rownames(counts))]
  qc <- qc %>%
    mutate(
      neg_counts = if (length(neg_genes) > 0) Matrix::colSums(counts[neg_genes, , drop = FALSE]) else NA_real_,
      bg_neg = if (length(neg_genes) > 0) neg_counts / pmax(Total_Counts, 1) else NA_real_
    )

  ## Standardize optional fields via the helpers ##
  qc <- qc %>%
    add_area_to_qc() %>%
    add_xy_to_qc(gobj = gobj, spat_unit = spat_unit)

  ## Choose grouping variable for area + tissue thresholds ##
  grp_col <- tissue_group[tissue_group %in% names(qc)][1]
  if (is.na(grp_col)) 
    grp_col <- NULL
  
  ## Area filtering, per sample. Keep area <= area_gm_mult * geometric mean ##
  ## Expects an area column. Might need name adjusting since Seurat used Area.um2 ##
  if ("area_um2" %in% names(qc) && any(is.finite(qc$area_um2) & qc$area_um2 > 0, na.rm = TRUE)) {

    if (!is.null(grp_col)) {
      qc <- qc %>%
        group_by(.data[[grp_col]]) %>%
        mutate(
          Geom_mean_area = exp(mean(log(area_um2[is.finite(area_um2) & area_um2 > 0]), na.rm = TRUE)),
          Threshold_area = area_gm_mult * Geom_mean_area
        ) %>%
        ungroup()
    } else {
      gm <- exp(mean(log(qc$area_um2[is.finite(qc$area_um2) & qc$area_um2 > 0]), na.rm = TRUE))
      qc <- qc %>% mutate(Geom_mean_area = gm, Threshold_area = area_gm_mult * gm)
    }

  } else {
    qc <- qc %>% mutate(Geom_mean_area = NA_real_, Threshold_area = Inf)
  }


  ## Background / negative probe ratios filtering ##
  ## Check if they exist in the object ##
  bg_present <- "bg_neg" %in% names(qc) && any(!is.na(qc$bg_neg))
  
  if (bg_present) {
  
    if ("Group" %in% names(qc)) {
      qc <- qc %>%
        group_by(Group) %>%
        mutate(thr_neg = quantile(bg_neg, bg_quantile, na.rm = TRUE)) %>%
        ungroup()
    } else {
      qc <- qc %>%
        mutate(thr_neg = quantile(bg_neg, bg_quantile, na.rm = TRUE))
    }
  
    qc <- qc %>%
      mutate(thr_neg = ifelse(is.finite(thr_neg), thr_neg, bg_fallback))
  
  } else {
    qc <- qc %>% mutate(thr_neg = Inf)
  }

  ## Tissue outlier filtering, per sample on x_slide_mm/y_slide_mm ##
  if (filter_tissue_outliers && all(c("x", "y") %in% names(qc)) &&
      any(is.finite(qc$x), na.rm = TRUE) && any(is.finite(qc$y), na.rm = TRUE)) {

    if (!is.null(grp_col)) {
      qc <- qc %>%
        group_by(.data[[grp_col]]) %>%
        mutate(
          x_low  = quantile(x, tissue_q[1], na.rm = TRUE),
          x_high = quantile(x, tissue_q[2], na.rm = TRUE),
          y_low  = quantile(y, tissue_q[1], na.rm = TRUE),
          y_high = quantile(y, tissue_q[2], na.rm = TRUE)
        ) %>%
        ungroup()
    } else {
      qc <- qc %>%
        mutate(
          x_low  = quantile(x, tissue_q[1], na.rm = TRUE),
          x_high = quantile(x, tissue_q[2], na.rm = TRUE),
          y_low  = quantile(y, tissue_q[1], na.rm = TRUE),
          y_high = quantile(y, tissue_q[2], na.rm = TRUE)
        )
    }

  } else {
    qc <- qc %>% mutate(x_low = -Inf, x_high = Inf, y_low = -Inf, y_high = Inf)
  }

  ## Apply the filtering rules ##
  qc <- qc %>%
    mutate(
      keep =
        ## Area constraint ##
        (is.na(area_um2) | (is.finite(area_um2) & area_um2 > 0 & area_um2 <= Threshold_area)) &
        ## Gene number ##
        (Num_Features > cell_min_genes) &
        (Num_Features < cell_max_genes) &
        ## Background (allows for NA) ##
        (is.na(bg_neg) | bg_neg < thr_neg) &
        # (is.na(bg_falsecode) | bg_falsecode < thr_fc) &
        ## Tissue position ##
        (is.na(x) | (x >= x_low & x <= x_high)) &
        (is.na(y) | (y >= y_low & y <= y_high))
    )

  ## Select the final cells ##
  cells_keep <- qc %>% 
    filter(keep) %>% 
    pull(cell_ID)
  
  stopifnot(length(cells_keep) > 0)

  ## Subset Giotto object to kept cells ##
  gobj <- subsetGiotto(gobj, cell_ids = cells_keep)

  ## Re-filter features after removing cells (drops genes that became zero) ##
  gobj <- filterGiotto(
    gobj,
    feat_type = feat_type,
    expression_threshold = expr_threshold,
    feat_det_in_min_cells = gene_min_cells,
    min_det_feats_per_cell = cell_min_genes
  )

  ## Return the object and the QC metrics ##
  list(gobject = gobj, qc_table = qc)
}

# cosmx <- filterGiotto(cosmx,
#     feat_type = "rna",
#     expression_threshold = 1,
#     feat_det_in_min_cells = 10,
#     min_det_feats_per_cell = 100
# )

```

```{r Apply the filtering}

res <- filter_cosmx_giotto(cosmx)
cosmx_filt <- res$gobject
qc <- res$qc_table

## QC report ##
qc %>% summarise(
  n_before = n(),
  n_keep = sum(keep, na.rm = TRUE),
  pct_drop = 100 * (1 - n_keep / n_before)
)

```









```{r Normalisation}

cosmx_norm <- normalizeGiotto(
  gobject = cosmx_filt,
  norm_methods = "standard",
  scalefactor = 6000,
  scale_order = "first_feats"
)

```

```{r Expression distibutions}

filterDistributions(cosmx_norm,
    plot_type = "hist",
    detection = "cells",
    method = "sum",
    feat_type = "rna",
    nr_bins = 100,
    save_param = list(
        save_name = "3_filter_dist_rna",
        base_height = 3
    )
)

## If you have negative probs ##
# filterDistributions(cosmx,
#     plot_type = "hist",
#     detection = "cells",
#     method = "sum",
#     feat_type = "negprobes",
#     nr_bins = 25,
#     save_param = list(
#         save_name = "4_filter_dist_negprobes",
#         base_height = 3
#     )
# )

```

```{r Density plots}

spatFeatPlot2D(
  gobject = cosmx_norm,
  spat_unit = "cell",
  feat_type = "rna",
  show_image = FALSE,
  expression_values = "normalized",     # or "raw" if you didnâ€™t normalize
  feats = c("MMP2","EPCAM"),
  cow_n_col = 2,
  point_size = 0.4,
  save_plot = TRUE,
  save_param = list(save_name = "5_gene_spatial", base_width = 16, base_height = 8, dpi = 300)
)

```

```{r Basic stats}

cosmx_norm <- addStatistics(cosmx_norm, expression_values = "raw")
cosmx_norm <- addStatistics(cosmx_norm, expression_values = "normalized")

## Mitochondrial counts ##
mt <- grep("^MT-", fDataDT(cosmx_norm)$feat_ID, value = TRUE)
if (length(mt)) {
  cosmx_norm <- addFeatsPerc(cosmx_norm, feats = mt, vector_name = "mito")
}

## Inspect QC ##
spatPlot2D(gobject = cosmx_norm,
           show_image = FALSE,
           point_alpha = 1,
           point_size = 1,
           cell_color = "nr_feats", color_as_factor = F)

spatPlot2D(gobject = cosmx_norm,
           show_image = FALSE,
           point_alpha = 1,
           point_size = 1,
           cell_color = "total_expr", color_as_factor = F)

if ("mito" %in% colnames(pDataDT(cosmx_norm))) {
  spatPlot2D(cosmx_norm, show_image = FALSE, cell_color = "mito", point_size = 0.2)
}


```

```{r Analysis time}

pDataDT(cosmx_norm)
fDataDT(cosmx_norm)

locs <- Giotto::getSpatialLocations(
  gobject = cosmx_norm,
  spat_unit = "cell"
)

p <- spatPlot2D(gobject = cosmx_norm, 
                show_image   = TRUE,
                point_size   = 0.2,
                point_alpha  = 0.7,
                return_plot  = TRUE) 

```


```{r Filter MT counts}

mitochondrial_genes <- grep("MT-", cosmx_norm@feat_ID, value = T)

cosmx_norm = addFeatsPerc(gobject = cosmx_norm,
                                feats = mitochondrial_genes, 
                                vector_name = "mito")

# mitochondrial content percentage
spatPlot2D(gobject = cosmx_norm,
           show_image = FALSE,
           point_alpha = 1,
           point_size = 1,
           cell_color = "mito", color_as_factor = F)

```

```{r Highly variable features}

HVF_cosmx <- calculateHVF(gobject = cosmx_norm, 
                          method = "cov_loess", 
                          var_number = 500, 
                          save_plot = TRUE, 
                          show_plot = TRUE, 
                          save_param = list(save_name = "7_HVF.png", 
                                            base_width = 16, 
                                            base_height = 8, 
                                            dpi = 300))

hvgs <- fDataDT(HVF_cosmx)[hvf == "yes", feat_ID]

```

```{r Remove duplicates using the custom function}

source("Remove_HVF_duplicates.R")

## After HVF calculation ##
dedup_result <- remove_hvf_duplicates(
  gobj = HVF_cosmx,
  hvgs = hvgs,
  output_dir = output_directory,
  verbose = TRUE
)

## Update objects ##
HVF_cosmx <- dedup_result$gobject
cosmx_norm <- dedup_result$gobject

cat("\nFinal cell count:", length(HVF_cosmx@cell_ID$cell), "\n")
cat("Cells removed:", dedup_result$n_removed, "\n")

## Verify polygons are still valid ##
tryCatch({
  showGiottoSpatialInfo(HVF_cosmx)
  cat("Polygons are valid\n")
}, error = function(e) {
  cat("Polygon error:", conditionMessage(e), "\n")
})

cat("\nHVF duplicate removal complete\n")

```

```{r PCA}

cosmx_dim <- runPCA(
  gobject = HVF_cosmx,
  feat_type = "rna",
  expression_values = "normalized",  
  scale_unit = FALSE,                
  center = TRUE,
  feats_to_use = hvgs,               
  ncp = 30
)

screePlot(cosmx_dim,
    ncp = 20, 
    save_param = list(
        save_name = "8_scree"
    )
)

```

```{r Visualise the PCA}

plotPCA(cosmx_dim,
    cell_color = "nr_feats",
    dim1_to_use = 1,
    dim2_to_use = 2,
    color_as_factor = FALSE,
    point_size = 0.8,
    gradient_style = "sequential",
    point_border_stroke = 0,
    background_color = "white",
    save_param = list(
        save_name = "9_pca"
    )
)

plotPCA_3D(cosmx_dim,
    cell_color = "nr_feats",
    dim1_to_use = 1,
    dim2_to_use = 2,
    dim3_to_use = 3,
    color_as_factor = FALSE,
    point_size = 0.8,
    save_param = list(
        save_name = "10_pca_3D"
    ))

```

```{r Nearest neighbour graph}

cosmx_dim <- createNearestNetwork(
  gobject = cosmx_dim,
  dim_reduction_to_use = "pca",
  dim_reduction_name = "pca",
  k = 15
)

nn <- getNearestNetwork(
  gobject = cosmx_dim, 
  nn_type = "sNN", 
  name = "sNN.pca" 
)

```


```{r Inspect the sNN}

source("Inspect_sNN_network.R")

results <- inspect_nn_network(
  gobject = cosmx_dim,
  nn_name = "sNN.pca",
  output_dir = output_directory,
  sample_id = "cosmx_sample1",
  n_cells_subgraph = 100000,
  save_plots = TRUE,
  verbose = TRUE
)

```

```{r UMAP}

cosmx_dim <- runUMAP(
  gobject = cosmx_dim,
  dim_reduction_to_use = "pca",
  dim_reduction_name = "pca",
  n_components = 2
)

```

```{r UMAP visualisation}

plotUMAP(
  cosmx_dim,
  dim_reduction_name = "umap",
  show_NN_network = TRUE,     
  point_size = 0.1
)

```

```{r tSNE}

cosmx_dim <- runtSNE(cosmx_dim,
                     dim_reduction_to_use = "pca", 
                     dimensions_to_use = 1:10, 
                     perplexity = 30, theta = 0.5, 
                     check_duplicates = TRUE
)

```

```{r Visualise the dimentionallity reductions by the fovs}

plotTSNE(cosmx_dim,
    cell_color = "fov",
    show_center_label = FALSE,
    save_param = list(
        save_name = "11_tsne_fov"
    )
)

plotUMAP(cosmx_dim,
    cell_color = "fov",
    show_center_label = FALSE,
    save_param = list(
        save_name = "12_umap_fov"
    )
)

```

```{r Load the Marker dataframe and check existing genes in the panel}

B_markers <- read_csv(file.path(main_dir, "B_Markers/B_Cell_Markers.csv")) %>% 
  mutate(Gene = str_replace(Gene, pattern = "\\*", replacement = ""))

panel_genes <- fDataDT(cosmx_dim, feat_type = "rna")$feat_ID

panel_genes %>% 
  grep("\\*", ., value = TRUE)

B_markers_clean <- B_markers %>%
  mutate(Gene = coalesce(Gene, ""),
         Synonyms = coalesce(Synonyms, "")) %>%
  pivot_longer(c(Gene, Synonyms), names_to = "source", values_to = "symbol_raw") %>%
  mutate(symbol_raw = str_squish(as.character(symbol_raw))) %>%
  separate_rows(symbol_raw, sep = "\\s*[+,]\\s*") %>%
  mutate(Gene = toupper(str_squish(symbol_raw))) %>%
  filter(Gene != "", !is.na(Gene)) %>%
  select(-symbol_raw) %>% 
  select(Gene, everything())

marker_presence_df <- tibble(Marker = B_markers_clean$Gene) %>%
  distinct() %>%
  mutate(Marker = toupper(Marker),
         in_panel = Marker %in% toupper(panel_genes)) %>%
  arrange(desc(in_panel), Marker)

marker_presence_df %>% 
  filter(in_panel == TRUE)


```

```{r Visualisation of the B marker feature plots}

source("Arrange_Feature_plots.R")
source("Feature_plots_panel.R")

## Get UMAP coordinates ##
umap_coords <- getDimReduction(
  gobject = cosmx_dim,
  reduction = "cells",
  reduction_method = "umap",
  name = "umap",
  output = "matrix"
)

umap_df <- as.data.frame(umap_coords)
colnames(umap_df) <- c("UMAP_1", "UMAP_2")
umap_df$cell_ID <- rownames(umap_df)

## Get normalized expression matrix ##
expr_norm <- getExpression(
  gobject = cosmx_dim,
  values = "normalized",
  output = "matrix"
)

## Calculate global expression limits for consistent legend ##
B_markers_present <- marker_presence_df %>% 
  filter(in_panel == TRUE) %>% 
  pull(Marker)

## Get expression values for all B markers ##
b_marker_expr <- expr_norm[B_markers_present, ]
global_expr_max <- max(b_marker_expr, na.rm = TRUE)
global_expr_limits <- c(0, global_expr_max)

cat("Global expression range for B markers: 0 to", round(global_expr_max, 2), "\n")

## Create optimal panel layout ##
marker_panels <- create_marker_panels(B_markers_present)

## Create enhanced panels with consistent legend ##
out_dir <- file.path(results_folder, "B_marker_umap_panels")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

for (i in seq_along(marker_panels)) {
  
  panel <- marker_panels[[i]]
  markers_in_panel <- panel$markers
  grid_dims <- panel$grid
  
  cat("\nCreating panel", i, "of", length(marker_panels), "\n")
  cat("Number of markers:", paste(length(markers_in_panel)), "\n")
  cat("Markers:", paste(head(markers_in_panel, 10), collapse = ", "), "\n")
  cat("Grid:", grid_dims$ncol, "x", grid_dims$nrow, "\n")
  
  ## Create individual plots with consistent limits ##
  plot_list <- lapply(markers_in_panel, function(marker) {
    create_feature_plot(
      feature = marker, 
      umap_df = umap_df, 
      expr_matrix = expr_norm,
      expr_limits = global_expr_limits,
      point_size_low = 0.1,
      point_size_high = 0.5,
      alpha_low = 0.3,
      alpha_high = 0.9
    )
  })
  
  ## Remove NULL plots ##
  plot_list <- plot_list[!sapply(plot_list, is.null)]
  
  if (length(plot_list) > 0) {
    ## Combine plots with shared legend ##
    combined_plot <- wrap_plots(
      plot_list,
      ncol = grid_dims$ncol,
      guides = "collect"
    ) +
      plot_annotation(
        title = sprintf("B Cell Markers - Panel %d/%d", i, length(marker_panels)),
        theme = theme(
          plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
          plot.background = element_rect(fill = "white", color = NA)
        )
      ) &
      theme(legend.position = "right")
    
    ## Save panel ##
    ggsave(
      filename = file.path(out_dir, sprintf("B_markers_panel_%02d.png", i)),
      plot = combined_plot,
      width = grid_dims$ncol * 4.5,
      height = grid_dims$nrow * 3,
      units = "in",
      dpi = 300,
      bg = "white"
    )
    
    cat("Panel", i, "saved successfully\n")
  }
}

cat("\nAll panels saved to:", out_dir, "\n")

```

```{r leiden clustering}

## Normal doLeidenCluster fails due to python. Haven't troubleshooted why ##
cosmx_dim <- doLeidenClusterIgraph(
  gobject = cosmx_dim,
  spat_unit = "cell",
  feat_type = "rna",
  nn_network_to_use = "sNN",
  network_name = "sNN.pca",
  resolution = 0.1,
  name = "leiden_clus"
)

clus_colors <- getColors("Vivid", length(unique(cosmx_dim$leiden_clus)))

```

```{r leiden clustering visualisation}

# Get UMAP coordinates
umap_coords <- getDimReduction(
  gobject = cosmx_dim,
  reduction = "cells",
  reduction_method = "umap",
  name = "umap",
  output = "matrix"
)

# Get tSNE coordinates
tsne_coords <- getDimReduction(
  gobject = cosmx_dim,
  reduction = "cells",
  reduction_method = "tsne",
  name = "tsne",
  output = "matrix"
)

# Get cluster labels
metadata <- pDataDT(cosmx_dim)

# Create UMAP plot data - ensure cluster is factor
umap_df <- umap_coords %>%
  as.data.frame() %>%
  setNames(., c("UMAP_1", "UMAP_2")) %>%
  rownames_to_column(var = "cell_ID") %>%
  inner_join(metadata %>%
    select(cell_ID, leiden_clus), by = "cell_ID") %>%
  mutate(cluster = factor(as.character(metadata$leiden_clus),
    levels = as.character(sort(unique(as.integer(metadata$leiden_clus))))
  ))

# Create tSNE plot data - ensure cluster is factor
tsne_df <- tsne_coords %>% 
  as.data.frame() %>%
  setNames(., c("tSNE_1", "tSNE_2")) %>%
  rownames_to_column(var = "cell_ID") %>%
  inner_join(metadata %>%
    select(cell_ID, leiden_clus), by = "cell_ID") %>%
  mutate(cluster = factor(as.character(metadata$leiden_clus),
    levels = as.character(sort(unique(as.integer(metadata$leiden_clus))))
  ))

# Get unique cluster levels
cluster_levels <- sort(as.numeric(levels(umap_df$cluster)))
n_clusters <- length(cluster_levels)

cat("Number of clusters detected:", n_clusters, "\n")
cat("Cluster IDs:", paste(cluster_levels, collapse = ", "), "\n")

# Create or verify clus_colors
if (!exists("clus_colors") || length(clus_colors) < n_clusters) {
  clus_colors <- getColors(palette = "Paired", n = n_clusters)
  names(clus_colors) <- as.character(cluster_levels)
} else {
  # Ensure names match cluster levels
  if (is.null(names(clus_colors))) {
    names(clus_colors) <- as.character(cluster_levels[1:min(length(clus_colors), n_clusters)])
  }
  # Trim or extend if needed
  clus_colors <- clus_colors[1:n_clusters]
  names(clus_colors) <- as.character(cluster_levels)
}

# Print color mapping
cat("\nCluster color mapping:\n")
print(data.frame(
  Cluster = names(clus_colors),
  Color = clus_colors,
  row.names = NULL
))

# Custom UMAP plot
custom_umap <- ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color = cluster)) +
  geom_point(size = 1, alpha = 0.8, stroke = 0) +
  scale_color_manual(
    values = clus_colors,
    name = "Leiden Cluster"
  ) +
  labs(
    title = "Cell Clusters - UMAP Projection",
    x = "UMAP Dimension 1",
    y = "UMAP Dimension 2"
  ) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    axis.title = element_text(size = 13, face = "bold"),
    axis.text = element_text(size = 11),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right",
    panel.background = element_rect(fill = "white"),
    plot.background = element_rect(fill = "white")
  ) +
  guides(color = guide_legend(override.aes = list(size = 3, alpha = 1)))

ggsave(
  filename = file.path(results_folder, "14_leiden_umap.png"),
  plot = custom_umap,
  width = 11,
  height = 8,
  dpi = 300,
  bg = "white"
)

# Custom tSNE plot
custom_tsne <- ggplot(tsne_df, aes(x = tSNE_1, y = tSNE_2, color = cluster)) +
  geom_point(size = 1, alpha = 0.8, stroke = 0) +
  scale_color_manual(
    values = clus_colors,
    name = "Leiden Cluster"
  ) +
  labs(
    title = "Cell Clusters - t-SNE Projection",
    x = "t-SNE Dimension 1",
    y = "t-SNE Dimension 2"
  ) +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    axis.title = element_text(size = 13, face = "bold"),
    axis.text = element_text(size = 11),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right",
    panel.background = element_rect(fill = "white"),
    plot.background = element_rect(fill = "white")
  ) +
  guides(color = guide_legend(override.aes = list(size = 3, alpha = 1)))

ggsave(
  filename = file.path(results_folder, "15_leiden_tsne.png"),
  plot = custom_tsne,
  width = 11,
  height = 8,
  dpi = 300,
  bg = "white"
)

# Side-by-side comparison
combined_dim_reduction <- (custom_umap | custom_tsne) +
  plot_annotation(
    title = "Leiden Clustering Results",
    theme = theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 18))
  )

ggsave(
  filename = file.path(results_folder, "16_leiden_umap_tsne.png"),
  plot = combined_dim_reduction,
  width = 20,
  height = 8,
  dpi = 300,
  bg = "white"
)

cat("\nPlots saved to:", results_folder, "\n")

```

```{r Spatial plot with leiden Giotto}

spatDimPlot2D(cosmx_dim,
    show_image = FALSE,
    # image_name = image_names,
    cell_color = "leiden_clus",
    cell_color_code = clus_colors,
    spat_point_size = 1,
    show_plot = TRUE,
    save_param = list(
        base_width = 9,
        base_height = 15,
        save_name = "17_sdplot"
    )
)

```

```{r}

spat_locs <- getSpatialLocations(
  gobject = cosmx_dim,
  spat_unit = "cell",
  output = "data.table"
)

# Get cluster assignments
metadata <- pDataDT(cosmx_dim)

# Combine spatial and cluster data
spatial_df <- spat_locs %>%
  as_tibble() %>%
  select(cell_ID, sdimx, sdimy) %>%
  inner_join(
    metadata %>% select(cell_ID, leiden_clus),
    by = "cell_ID"
  ) %>%
  mutate(
    cluster = factor(
      as.character(leiden_clus),
      levels = as.character(sort(unique(as.integer(leiden_clus))))
    )
  )


# Create enhanced spatial plot
custom_spatial <- ggplot(spatial_df, aes(x = sdimx, y = sdimy, color = cluster)) +
  geom_point(size = 1, alpha = 0.8, stroke = 0) +
  scale_color_manual(
    values = clus_colors,
    name = "Leiden Cluster"
  ) +
  labs(
    title = "Spatial Distribution of Cell Clusters",
    x = "Spatial X (microns)",
    y = "Spatial Y (microns)"
  ) +
  coord_fixed() +
  theme_classic() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    axis.title = element_text(size = 13, face = "bold"),
    axis.text = element_text(size = 11),
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10),
    legend.position = "right",
    panel.background = element_rect(fill = "white"),
    plot.background = element_rect(fill = "white")
  ) +
  guides(color = guide_legend(override.aes = list(size = 3, alpha = 1)))


combined_leiden <- (custom_umap + custom_tsne + custom_spatial) +
  plot_layout(guides = "collect") +
  plot_annotation(title = "Leiden Clustering Results", 
                  theme = theme(plot.title = element_text(hjust = 0.5, 
                                                          face = "bold", 
                                                          size = 18)))
ggsave(
  filename = file.path(results_folder, "18_leiden_final.png"),
  plot = combined_leiden,
  width = 20,
  height = 10,
  dpi = 300,
  bg = "white"
)


```

